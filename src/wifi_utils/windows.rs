use std::process::Command;
use super::WifiNetwork;

// Include the constants generated by build.rs
include!(concat!(env!("OUT_DIR"), "/generated_translations.rs"));

// Helper function to check if a line part matches any keyword in a list (case-insensitive for the line_key_part)
fn line_key_matches_any(line_key_part: &str, keywords: &[&str]) -> bool {
    let trimmed_lower_key = line_key_part.trim().to_lowercase();
    keywords.iter().any(|&kw| kw.to_lowercase() == trimmed_lower_key)
}

pub fn get_known_networks() -> Result<Vec<WifiNetwork>, String> {
    let output = Command::new("netsh")
        .args(&["wlan", "show", "profiles"])
        .output()
        .map_err(|e| format!("Failed to execute 'netsh wlan show profiles'. Is WLAN AutoConfig service running? Error: {}", e))?;

    if !output.status.success() {
        let error_message = String::from_utf8_lossy(&output.stderr);
        return Err(format!("'netsh wlan show profiles' command failed with status {}: {}.", output.status, error_message));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let mut networks = Vec::new();

    for line in stdout.lines() {
        if let Some(colon_pos) = line.rfind(':') { // Find the last colon
            let potential_key_part = &line[..colon_pos];
            let potential_ssid_part = &line[colon_pos + 1..];

            // Check if the part before the last colon (trimmed) matches any "All User Profile" keyword
            if line_key_matches_any(potential_key_part.trim_start(), ALL_USER_PROFILE_KEYWORDS) {
                let ssid = potential_ssid_part.trim().to_string();
                // Skip empty or placeholder SSIDs like "<Kein>" (German for <None>) or "<none>"
                if ssid.is_empty() || ssid.eq_ignore_ascii_case("<Kein>") || ssid.eq_ignore_ascii_case("<none>") {
                    continue;
                }

                let profile_output_result = Command::new("netsh")
                    .args(&["wlan", "show", "profile", &format!("name={}", ssid), "key=clear"])
                    .output();
            
                let mut password = None;
                let mut security_type = None;

                match profile_output_result {
                    Ok(prof_out) => {
                        if prof_out.status.success() {
                            let profile_details = String::from_utf8_lossy(&prof_out.stdout);
                            let mut key_content_value: Option<String> = None;
                            let mut authentication_value: Option<String> = None;

                            for detail_line in profile_details.lines() {
                                if let Some(colon_pos_detail) = detail_line.find(':') { // Find the first colon
                                    let key_part = &detail_line[..colon_pos_detail];
                                    let value_part = &detail_line[colon_pos_detail + 1..];

                                    if line_key_matches_any(key_part, KEY_CONTENT_KEYWORDS) {
                                        key_content_value = Some(value_part.trim().to_string());
                                    } else if line_key_matches_any(key_part, AUTHENTICATION_KEYWORDS) && authentication_value.is_none() {
                                        // Take the first authentication line, as there might be multiple for different ciphers
                                        authentication_value = Some(value_part.trim().to_uppercase());
                                    }
                                }
                            }
                        
                            // Filter out keys that indicate no password or are empty
                            password = key_content_value.filter(|k| !k.is_empty() && !k.eq_ignore_ascii_case("not present") && !k.eq_ignore_ascii_case("nicht vorhanden"));

                            if let Some(auth_str) = authentication_value {
                                if auth_str.contains("WPA2PSK") || auth_str.contains("WPAPSK") || auth_str.contains("WPA2-PERSONAL") || auth_str.contains("WPA-PERSONAL") || auth_str.contains("WPA3SAE") || auth_str.contains("WPA3-PERSONAL") {
                                    security_type = Some("WPA".to_string());
                                } else if auth_str.contains("WEP") {
                                    security_type = Some("WEP".to_string());
                                } else if auth_str.contains("OPEN") {
                                    security_type = Some("nopass".to_string());
                                }
                            }
                        } else {
                            // eprintln!("Could not retrieve details for profile '{}' (may require admin rights for password): {}", ssid, String::from_utf8_lossy(&prof_out.stderr));
                        }
                    }
                    Err(e) => {
                        eprintln!("Failed to execute 'netsh wlan show profile name={}': {}.", ssid, e);
                    }
                }
                networks.push(WifiNetwork { ssid, password, security_type });
            }
        }
    }
    if networks.is_empty() {
         println!("No Wi-Fi profiles found using 'netsh', or unable to retrieve their details. You can enter network details manually.");
    }
    Ok(networks)
}

pub fn fetch_password_for_ssid(ssid: &str) -> Result<Option<String>, String> {
    let profile_output = Command::new("netsh")
        .args(&["wlan", "show", "profile", &format!("name={}", ssid), "key=clear"])
        .output()
        .map_err(|e| format!("Failed to execute 'netsh wlan show profile name={}' key=clear': {}", ssid, e))?;

    if !profile_output.status.success() {
        let error_message_stderr = String::from_utf8_lossy(&profile_output.stderr).trim().to_string();
        let error_message_stdout = String::from_utf8_lossy(&profile_output.stdout).trim().to_string();

        let mut detailed_error = String::new();
        if !error_message_stderr.is_empty() {
            detailed_error.push_str(&format!("Stderr: {}", error_message_stderr));
        }
        // Sometimes errors also end up in stdout
        if !error_message_stdout.is_empty() {
            if !detailed_error.is_empty() { 
                detailed_error.push_str("; "); 
            }
            // Show only a part of stdout if it's very long (e.g., the entire profile output without an error)
            const MAX_STDOUT_ERROR_LEN: usize = 200;
            if error_message_stdout.len() > MAX_STDOUT_ERROR_LEN {
                detailed_error.push_str(&format!("Stdout (truncated): {}...", &error_message_stdout[..MAX_STDOUT_ERROR_LEN]));
            } else {
                detailed_error.push_str(&format!("Stdout: {}", error_message_stdout));
            }
        }

        if detailed_error.is_empty() {
            detailed_error = format!("Command failed with exit code {:?}, but no specific error message found on stderr or stdout.", profile_output.status.code());
        }

        return Err(format!("'netsh wlan show profile name={} key=clear' command failed: {}. Administrator rights might be required.", ssid, detailed_error));
    }

    let profile_details = String::from_utf8_lossy(&profile_output.stdout);
    let mut key_content_value: Option<String> = None;

    for detail_line in profile_details.lines() {
        if let Some(colon_pos) = detail_line.find(':') { // Find the first colon
            let key_part = &detail_line[..colon_pos];
            let value_part = &detail_line[colon_pos + 1..];

            if line_key_matches_any(key_part, KEY_CONTENT_KEYWORDS) {
                let potential_key = value_part.trim().to_string();
                // Filter out keys that indicate no password or are empty
                if !potential_key.is_empty() && !potential_key.eq_ignore_ascii_case("not present") && !potential_key.eq_ignore_ascii_case("nicht vorhanden") {
                    key_content_value = Some(potential_key);
                    break; 
                }
            }
        }
    }
    Ok(key_content_value)
}
